package com.revature.data;

import com.revature.entity.Pet;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

// Here, we are going to implement some methods that interact with the database:
public class PetDaoImpl implements PetDao{

    Connection connection;

    // constructor initialize the connection based on our connection factory:
    public PetDaoImpl() {
        connection = ConnectionFactory.getConnection();
    }

    // take in a pet object and return the pet with the updated id
    @Override
    public Pet insert(Pet pet) {
        System.out.println(pet.toString());
        System.out.println("Now we're in the DAO trying to pass in pet object to the database");
        // As the code is right now, we insert the same pet over and over again
        // String sql = "insert into pet (id, name, species, food) values (default, 'Ashes', 'cat', 'tuna');";

        // This is dangerous, SQLInjection, if we use string concatenation, bad people can sneak in very dangerous commands:
        // very unpredicatable
//        String sql = "insert into pet(id, name, species, food) values (default, " + pet.getName() + "," +  pet.getFood();
//        System.out.println(sql);

        // wherever we want to include a value, we leave it as a question mark for now:
        String sql = "insert into pet(id, name, species, food) values (default, ?, ?, ?);";

        try {
            // here, we pass in a flag that tells the program that we want to return the generated id:
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            // taking our statement and setting up the values based on where we put the ?
            preparedStatement.setString(1, pet.getName());
            preparedStatement.setString(2, pet.getSpecies());
            preparedStatement.setString(3, pet.getFood());
            System.out.println(preparedStatement.toString());

            // we've set up the string but we haven't executed the statement
            // we use the executeUpdate method whenever we do DML operations (insert, update, delete):
            // going to return the number of records that were updated (or in this case inserted)
            int count = preparedStatement.executeUpdate();
            // we've successfully inserted a single record
            if(count == 1) {
                System.out.println("Pet added successfully.");
                // Now, we have to get the id that was generated by the database
                // whenever we get a return value from the database, we store it in a result set:
                ResultSet resultSet = preparedStatement.getGeneratedKeys();
                // right when we get our result set, it actually points to nothing, so we increment it:
                resultSet.next();
                /**
                 * Generated id might look like this:
                 * -------
                 * |  1  |
                 * -------
                 */
                // because result sets in general can return multiple values, we have to specify which one we want
                // but in this case, there's only one value so we take the first one
                int generatedId = resultSet.getInt(1);
                // set the id to the original object:
                pet.setId(generatedId);
            }
            else {
                System.out.println("Something went wrong with the insert!");
            }
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("Something went wrong when preparing the statement!");
        }

        return pet;
    }

    // getting data, rather than inserting:
    @Override
    public Pet getById(int id) {
        String sql = "select * from pet where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            //
            preparedStatement.setInt(1, id);
            System.out.println(preparedStatement);
            // Now that we've prepared the statement, we just want to execute it:
            // Result set is going to store the return value of the query:
            ResultSet resultSet = preparedStatement.executeQuery();

            // make sure we actually got a value from the query:
            if(resultSet.next()) {
                // parse out and extract the data
                int idDb = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String species = resultSet.getString("species");
                String food = resultSet.getString("food");
                // use the data to create a pet object
                Pet pet = new Pet(idDb, name, species, food);
                // return the pet object
                return pet;
            }
            else {
                System.out.println("something went wrong when trying to query for the pet, pet might not exist");
            }
        } catch (SQLException e) {
            System.out.println("Something went wrong when trying to retrieve data.");
            e.printStackTrace();

        }
        // if we reach the end of this method, return null
        return null;

        /**
         * if(username already taken)
         * try {
         * throw new RegisterException
         * }
         * catch RegisterException{
         * print stackTrace
         */
    }

    @Override
    public List<Pet> getAllPets() {
        // set up a list to store the return values (pets)
        List<Pet> pets = new ArrayList<>();

        // no actual parameter values here
        String sql = "select * from pet;";
        try {
            // Use a simple statement here, because we don't have to change any parameters:
            Statement statement= connection.createStatement();

            ResultSet resultSet = statement.executeQuery(sql);

            // As opposed to :
            // PreparedStatement preparedStatement = connection.prepareStatement(sql);
            // statement.executeQuery()

            // now we're getting multiple pets so we use the while loop
            // we use a while loop that keeps incrementing the result set until we reach the end (null)
            while(resultSet.next()) {
                // for the current row, extract the data
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String species = resultSet.getString("species");
                String food = resultSet.getString("food");
                Pet pet = new Pet(id, name, species, food);

                // add the current pet to the list of pets that we're returning:
                pets.add(pet);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // at the very end, return pets:
        return pets;
    }

    // For update, we take in some information and update a pre-existing record in the table:
    @Override
    public Pet update(Pet pet) {
        String sql = "update pet set name = ?, species = ?, food = ? where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, pet.getName());
            preparedStatement.setString(2, pet.getSpecies());
            preparedStatement.setString(3, pet.getFood());
            preparedStatement.setInt(4, pet.getId());

            int count = preparedStatement.executeUpdate(); // DML, we use executeUpdate instead of executeQuery

            if(count == 1) {
                System.out.println("Update successful!");
                return pet;
            }
            else {
                System.out.println("Something went wrong with the update");
                if(count == 0) {
                    System.out.println("No rows were affected");
                }
                else {
                    System.out.println("Many rows were affected");
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        // return null
        return null;
    }

    // only update a certain field/column:
//    public Pet updateFood(int id, String food) {
//        String sql = "update pet set food = ? where id = ?;";
//        PreparedStatement preparedStatement = connection.prepareStatement();
//        preparedStatement.setString(food);
//        preparedStatement.setInt(2, id);
//
//    }

    // return a boolean of whather the deletion was successful:
    @Override
    public boolean delete(int id) {
        String sql = "delete from pet where id = ?;";
        try {
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, id);

            int count = preparedStatement.executeUpdate();
            if(count == 1) {
                System.out.println("Deletion successful!");
                return true;
            }
            else {
                return false;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    // CRUD Methods:


}
